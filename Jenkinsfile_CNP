#!groovy
import groovy.transform.Field
import uk.gov.hmcts.contino.GithubAPI

@Library('Infrastructure')

// Pipeline identifiers
String opalName = 'opal'
String type = 'angular'
String product = opalName
String component = 'frontend'
@Field String masterProjectName = 'HMCTS/opal-frontend/master'

// Secret key for KeyVault lookups
String secretKey = 'opal-$'.concat('{env}')

// Common literals to reduce duplication warnings
String stageBuild = 'build'
String stageTest = 'test'
String stageFunctionalDev = 'functionalTest:dev'
String stageFunctionalStg = 'functionalTest:stg'
String skipLabelComponent = 'skip_opal_component'
@Field String weightsRoot = 'cypress/parallel/weights'
@Field String pipelineWeightsDir = "${weightsRoot}/pipeline"
@Field String smokeWeights = 'smoke-parallel-weights.json'
@Field String functionalWeights = 'functional-parallel-weights.json'
@Field String componentWeights = 'component-parallel-weights.json'
@Field String functionalArtifactsGlob = 'functional-output/**'
@Field String weightsPipelineArtifactsFilter = '**/cypress/parallel/weights/pipeline/*'
@Field String mkdirPipelineCmd = "mkdir -p ${pipelineWeightsDir}"
@Field String copySmokeToPipelineCmd = "cp -r ${weightsRoot}/${smokeWeights} ${pipelineWeightsDir}/"
@Field String copyFunctionalToPipelineCmd = "cp -r ${weightsRoot}/${functionalWeights} ${pipelineWeightsDir}/"
String smokeXmlReport = 'cypress/reports/smokeXmlReport.html'
String functionalXmlReport = 'cypress/reports/functionalXmlReport.html'
String defaultBrowser = 'chrome'
String browserToRun = (env.BROWSER_TO_RUN ?: defaultBrowser).trim().toLowerCase()
String functionalOutputDir =
  browserToRun == defaultBrowser
    ? 'functional-output/prod/cucumber/'
    : "functional-output/prod/${browserToRun}/cucumber/"
String functionalReportFile =
  browserToRun == defaultBrowser
    ? 'functional-report.html'
    : "${browserToRun}-report.html"
String functionalReportName =
  browserToRun == defaultBrowser
    ? 'Cucumber Functional Test Report'
    : "Cucumber Functional Test Report (${browserToRun})"
String smokeOutputDir = 'smoke-output/prod/cucumber/'
String smokeReportFile = 'smoke-report.html'
String smokeReportName = 'Cucumber Smoke Test Report'
String accountArtifactPath = 'functional-output/account_evidence/created-accounts.json'
String accountEvidenceArtifacts = 'functional-output/account_evidence/**'
String runTagPrefix = 'run_tag:'

// Vault secrets injected into the pipeline
Map<String, Object> secrets = [
  (secretKey): [
    secret('OpalTestUserEmail', 'OPAL_TEST_USER_EMAIL'),
    secret('OpalTestUserPassword', 'OPAL_TEST_USER_PASSWORD')
  ],
]

// Build an Azure KeyVault secret entry
static Map<String, Object> secret(String secretName, String envVar) {
    return [$class     : 'AzureKeyVaultSecret',
    secretType : 'Secret',
    name       : secretName,
    version    : '',
    envVariable: envVar
  ]
}

// Yarn helper for build/test commands
uk.gov.hmcts.contino.YarnBuilder yarnBuilder = new uk.gov.hmcts.contino.YarnBuilder(this)

void archiveArtifact(String path) {
    archiveArtifacts artifacts: path, allowEmptyArchive: true
}

// Publish an HTML report directory with Jenkins HTML Publisher
void publishHtmlReport(String dir, String files, String name) {
    publishHTML target: [
    allowMissing         : true,
    alwaysLinkToLastBuild: true,
    keepAll              : true,
    reportDir            : dir,
    reportFiles          : files,
    reportName           : name
  ]
}

// Resolve project/job name (PR vs master)
String getProjectName() {
    String projectPrefix = 'HMCTS/opal-frontend/'
    GithubAPI githubApi = new GithubAPI(this)
    echo "Branch name: ${env.BRANCH_NAME}"
    echo "Labels: ${githubApi.getLabels(env.BRANCH_NAME)}"
    List<String> candidateLabels = []
    candidateLabels.addAll(githubApi.getLabelsbyPattern(env.BRANCH_NAME, 'opal-frontend-pr-'))
    candidateLabels.addAll(githubApi.getLabelsbyPattern(env.BRANCH_NAME, 'rel:opal-frontend-pr-'))
    for (label in candidateLabels) {
        java.util.regex.Matcher matcher = (label =~ /opal-frontend-pr-(\d+)/)
        if (matcher.find()) {
            return projectPrefix + 'PR-' + matcher.group(1)
        }
    }
    return masterProjectName
}
// Collect test/skip labels for routing
List<String> getProjectLabels() {
    GithubAPI githubApi = new GithubAPI(this)
    List<String> testLabels = []
    for (String label in githubApi.getLabelsbyPattern(env.BRANCH_NAME, 'test_')) {
        testLabels.add(label)
    }
    for (String label in githubApi.getLabelsbyPattern(env.BRANCH_NAME, 'skip_')) {
        testLabels.add(label)
    }
    return testLabels
}
// Restore weight files from last successful build
void performArtifactOperations() {
    sh "${mkdirPipelineCmd}"

    sh """
    echo "Listing all artifacts before copy artifacts:"
    ls -l1a ${weightsRoot}/
    ls -l1a ${pipelineWeightsDir}/
    """

    script {
        String projectNameValue = projectName
        String fallbackProjectName = masterProjectName
        boolean copied = false
        try {
            copyArtifacts(
                projectName: projectNameValue,
                selector: lastSuccessful(),
                filter: weightsPipelineArtifactsFilter
      )
            copied = true
        } catch (hudson.AbortException e) {
            echo "Error copying artifacts from ${projectNameValue}: ${e}"
        }
        if (!copied && projectNameValue != fallbackProjectName) {
            try {
                copyArtifacts(
                    projectName: fallbackProjectName,
                    selector: lastSuccessful(),
                    filter: weightsPipelineArtifactsFilter
          )
                copied = true
            } catch (hudson.AbortException e) {
                echo "Error copying artifacts from ${fallbackProjectName}: ${e}"
            }
        }
        if (!copied) {
            echo 'No prior weight artifacts found; continuing without cached weights.'
        }

        sh """
        echo "Listing all artifacts after copy artifacts:"
        ls -l1a ${weightsRoot}/
        ls -l1a ${pipelineWeightsDir}/
        """
    }

    try {
        sh """
        if [ -f ${pipelineWeightsDir}/${smokeWeights} ]; then
            mv ${pipelineWeightsDir}/${smokeWeights} ${weightsRoot}/${smokeWeights}
            echo "Moved smoke-parallel-weights.json"
        else
            echo "smoke-parallel-weights.json not found, skipping move"
        fi
        if [ -f ${pipelineWeightsDir}/${functionalWeights} ]; then
            mv ${pipelineWeightsDir}/${functionalWeights} ${weightsRoot}/${functionalWeights}
            echo "Moved functional-parallel-weights.json"
        else
            echo "functional-parallel-weights.json not found, skipping move"
        fi
        if [ -f ${pipelineWeightsDir}/${componentWeights} ]; then
            mv ${pipelineWeightsDir}/${componentWeights} ${weightsRoot}/${componentWeights}
            echo "Moved component-parallel-weights.json"
        else
            echo "component-parallel-weights.json not found, skipping move"
        fi
        """
    } catch (hudson.AbortException e) {
        echo "Artifacts not found or copy failed: ${e}"
    }

    sh """
    echo "Listing all copied artifacts:"
    ls -l1a ${weightsRoot}/
    ls -l1a ${pipelineWeightsDir}/
    """
}

// Set TEST_SPECS based on labels or default to all
void setupTestSpecifications() {
    script {
        String projectNameValue = projectName
        List<String> labels = projectLabels
        sh "echo 'Test Labels: ${labels}'"

        List<String> directories = []

        // Add additional labels as needed
        if (labels.contains('test_authorisation')) {
            directories.add('authorisation')
        }
        if (labels.contains('test_enq')) {
            directories.add('accountEnquiry')
        }
        if (labels.contains('test_remo')) {
            directories.add('reciprocalMaintenance')
        }
        if (labels.contains('test_mac')) {
            directories.add('manualAccountCreation')
        }
        sh "echo 'Directories: ${directories}'"

        if (directories.empty || projectNameValue == masterProjectName) {
            // No specific test labels, include all directories
            env.TEST_SPECS = 'cypress/e2e/functional/opal/**/*.feature'
        } else {
            // Build the glob pattern using curly braces
            String dirList = directories.join(',')
            env.TEST_SPECS = "cypress/e2e/functional/opal/{required,${dirList}}/**/*.feature"
        }
        sh "echo 'Test Specs: ${env.TEST_SPECS}'"
    }
}

// Configure PR env deployment for dev fines service
void determineDevEnvironmentDeployment() {
    env.DEV_ENABLE_OPAL_FINES_SERVICE = true // Default to true for development environment as FE wont work without it
    env.DEV_OPAL_FINES_SERVICE_URL = "https://opal-frontend-pr-${env.CHANGE_ID}-fines-service.dev.platform.hmcts.net"
    env.DEV_OPAL_FINES_SERVICE_IMAGE_SUFFIX = 'latest'

    GithubAPI githubApi = new GithubAPI(this)
    if (githubApi.checkForLabel(env.BRANCH_NAME, 'enable_keep_helm')) {
        for (label in githubApi.getLabelsbyPattern(env.BRANCH_NAME, 'enable_opal_')) {
            //Fines service
            if (label ==~ /enable_opal_fines_service.*/) {
                env.DEV_ENABLE_OPAL_FINES_SERVICE = true
                env.DEV_OPAL_FINES_SERVICE_URL =
          "https://opal-frontend-pr-${env.CHANGE_ID}-fines-service.dev.platform.hmcts.net"
                if (label ==~ /enable_opal_fines_service:pr-.*/) {
                    env.DEV_OPAL_FINES_SERVICE_IMAGE_SUFFIX = label.replace('enable_opal_fines_service:', '')
                }
                echo "Deploying Opal fines service ${env.DEV_OPAL_FINES_SERVICE_URL}"
            }
        }
    }
}

// Fail the build if .only or @only are present
void checkFocusedTests() {
    sh '''
    echo "=== Focused test checks (component + feature) ==="
    set +e
    COMPONENT_ONLY_FILES=$(grep -R -l --include='*.cy.ts' '\\.only' cypress/component 2>/dev/null)
    FEATURE_ONLY_FILES=$(grep -R -l --include='*.feature' '@only' cypress/e2e/functional/opal/features 2>/dev/null)
    set -e

    HAS_FAILURE=0

    if [ -n "$COMPONENT_ONLY_FILES" ]; then
      echo ""
      echo "Found focused component specs (.only):"
      echo "$COMPONENT_ONLY_FILES" | sed 's/^/ - /'
      HAS_FAILURE=1
    else
      echo "No focused component specs found."
    fi

    if [ -n "$FEATURE_ONLY_FILES" ]; then
      echo ""
      echo "Found @only tags in feature files:"
      echo "$FEATURE_ONLY_FILES" | sed 's/^/ - /'
      HAS_FAILURE=1
    else
      echo "No @only tags found in feature files."
    fi

    if [ "$HAS_FAILURE" -eq 1 ]; then
      echo ""
      echo "FAIL: Remove the focused tests above before running component tests."
      exit 1
    fi
    echo "Focused test checks passed."
  '''
}

properties([
  // Permit dependent jobs to copy artifacts from this build
  copyArtifactPermission('*')
])

// --- Dev legacy toggle (PR label driven) ---
GithubAPI githubApiForMode = new GithubAPI(this)
boolean legacyEnabled = githubApiForMode.checkForLabel(env.BRANCH_NAME, 'enable_legacy_mode')
String changeId = env.CHANGE_ID?.trim()
boolean isPR = changeId != null && !changeId.empty

// Safe defaults (current behaviour)
env.DEV_DEFAULT_APP_MODE = opalName
env.DEV_OPAL_LEGACY_GATEWAY_URL = 'https://opal-legacy-db-stub.staging.platform.hmcts.net/opal'
env.OPAL_LOG_LEVEL = env.OPAL_LOG_LEVEL ?: 'INFO'

// Opt-in: Dev â†’ JCDE (PR builds only)
if (legacyEnabled && isPR) {
    env.DEV_DEFAULT_APP_MODE = 'legacy'
    env.DEV_OPAL_LEGACY_GATEWAY_URL = 'https://opal.clouddev.online/opal'
    env.OPAL_LOG_LEVEL = 'DEBUG'
} else if (legacyEnabled && !isPR) {
    echo 'Legacy mode label detected but this is not a PR build; ignoring.'
}

echo "DEV_DEFAULT_APP_MODE=${env.DEV_DEFAULT_APP_MODE}"
echo "DEV_OPAL_LEGACY_GATEWAY_URL=${env.DEV_OPAL_LEGACY_GATEWAY_URL}"
echo "OPAL_LOG_LEVEL=${env.OPAL_LOG_LEVEL}"

GithubAPI githubApi = new GithubAPI(this)
List<String> allLabels = githubApi.getLabels(env.BRANCH_NAME)

// Find the first label like: run_tag:<expression>
String tagLabel = allLabels.find { String label -> label.startsWith(runTagPrefix) }
String skipTagExpression = 'not @skip'

if (tagLabel) {
    String baseTags = tagLabel.substring(runTagPrefix.length()).trim()
    env.TAGS = baseTags ? "(${baseTags}) and ${skipTagExpression}" : skipTagExpression
    env.CYPRESS_TAGS = env.TAGS
    echo "Running scenarios matching TAGS=${env.TAGS}"
} else {
    env.TAGS = skipTagExpression
    env.CYPRESS_TAGS = env.TAGS
    echo "Running all scenarios except @skip (TAGS=${env.TAGS})"
}

// Primary pipeline definition and lifecycle hooks
withPipeline(type, product, component) {
    // Inject KeyVault secrets required for login/setup
    loadVaultSecrets(secrets)

    // Configure PR-only deployment knobs before helm installs run
    before('akschartsinstall') {
        onPR {
            determineDevEnvironmentDeployment()
        }
    }

    // Build frontend bundle after checkout when previous steps succeed
    afterSuccess(stageBuild) {
        yarnBuilder.yarn('rebuild puppeteer')
        yarnBuilder.yarn(stageBuild)
    }

    // Restore previous parallelization weights and set test spec globs
    afterSuccess('checkout') {
        performArtifactOperations()
        setupTestSpecifications()
        script {
            List<String> labels = projectLabels
            if (labels.contains(skipLabelComponent)) {
                echo "Skipping focused test checks due to label: ${skipLabelComponent}"
            } else {
                echo 'Running focused test checks (no skip label present)'
                checkFocusedTests()
            }
        }
    }

    // Persist updated component weights after component test stage
    afterSuccess(stageTest) {
        script {
            String sourceJobName = env.JOB_NAME
            sh "${mkdirPipelineCmd}"
            sh '''
          if [ -f cypress/parallel/weights/component-parallel-weights.json ]; then
            cp -r cypress/parallel/weights/component-parallel-weights.json cypress/parallel/weights/pipeline/
          else
            echo "component-parallel-weights.json not found, skipping copy"
          fi
          '''
            sh"echo 'Archiving weight files in ${sourceJobName}'"
            archiveArtifacts(
          artifacts: "${pipelineWeightsDir}/${componentWeights}",
          allowEmptyArchive: true
        )
        }
    }

    // Always run component suite unless explicitly skipped; publish artifacts
    afterAlways(stageTest) {
        script {
            List<String> labels = projectLabels
            if (labels.contains(skipLabelComponent)) {
                echo "Skipping opal component tests due to label: ${skipLabelComponent}"
      } else {
                echo 'Running opal component tests (no skip label present)'
                try {
                    yarnBuilder.yarn('test:opalComponent')
        } catch (hudson.AbortException e) {
                    echo "Opal component tests failed: ${e}"
                    currentBuild.result = 'FAILURE'
        } finally {
                    archiveArtifact(functionalArtifactsGlob)
                    publishHtmlReport('functional-output/component-report/', 'index.html', 'Component Test Report')
                }
            }
        }
    }

    // Archive smoke/functional weights and reports after dev functional run
    afterSuccess(stageFunctionalDev) {
        script {
            String sourceJobName = env.JOB_NAME
            sh "${mkdirPipelineCmd}"
            sh "${copySmokeToPipelineCmd}"
            sh "${copyFunctionalToPipelineCmd}"

            sh"echo 'Archiving weight files in ${sourceJobName}'"
            archiveArtifact("${pipelineWeightsDir}/${smokeWeights}")
            archiveArtifact("${pipelineWeightsDir}/${functionalWeights}")
            archiveArtifact(smokeXmlReport)
            archiveArtifact(functionalXmlReport)
        }
    }

    // Archive smoke/functional weights and reports after staging functional run
    afterSuccess(stageFunctionalStg) {
        script {
            String sourceJobName = env.JOB_NAME
            sh "${mkdirPipelineCmd}"
            sh "${copySmokeToPipelineCmd}"
            sh "${copyFunctionalToPipelineCmd}"

            sh"echo 'Archiving weight files in ${sourceJobName}'"
            archiveArtifact("${pipelineWeightsDir}/${smokeWeights}")
            archiveArtifact("${pipelineWeightsDir}/${functionalWeights}")
            archiveArtifact(smokeXmlReport)
            archiveArtifact(functionalXmlReport)
        }
    }

    // Publish HTML and JSON artifacts for staging functional runs
    afterAlways(stageFunctionalStg) {
        publishHtmlReport(
        functionalOutputDir,
        functionalReportFile,
        functionalReportName
      )
        archiveArtifact(functionalArtifactsGlob)
        archiveArtifact(accountArtifactPath)
        archiveArtifact(accountEvidenceArtifacts)
        publishHtmlReport(
        smokeOutputDir,
        smokeReportFile,
        smokeReportName
      )
    }
    // Publish HTML and JSON artifacts for dev functional runs
    afterAlways(stageFunctionalDev) {
        publishHtmlReport(
        functionalOutputDir,
        functionalReportFile,
        functionalReportName
      )
        archiveArtifact(functionalArtifactsGlob)
        archiveArtifact(accountArtifactPath)
        archiveArtifact(accountEvidenceArtifacts)

        publishHtmlReport(
        smokeOutputDir,
        smokeReportFile,
        smokeReportName
      )
    }
}
