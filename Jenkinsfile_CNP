#!groovy
import uk.gov.hmcts.contino.GithubAPI

@Library('Infrastructure')

// Pipeline identifiers
String type = 'angular'
String product = 'opal'
String component = 'frontend'

// Secret key for KeyVault lookups
String secretKey = 'opal-' + String.valueOf(env)

// Common literals to reduce duplication warnings
String stageBuild = 'build'
String stageTest = 'test'
String stageFunctionalDev = 'functionalTest:dev'
String stageFunctionalStg = 'functionalTest:stg'
String skipLabelComponent = 'skip_opal_component'
String weightsRoot = 'cypress/parallel/weights'
String pipelineWeightsDir = "${weightsRoot}/pipeline"
String smokeWeights = 'smoke-parallel-weights.json'
String functionalWeights = 'functional-parallel-weights.json'
String componentWeights = 'component-parallel-weights.json'
String mkdirPipelineCmd = "mkdir -p ${pipelineWeightsDir}"
String copySmokeToPipelineCmd = "cp -r ${weightsRoot}/${smokeWeights} ${pipelineWeightsDir}/"
String copyFunctionalToPipelineCmd = "cp -r ${weightsRoot}/${functionalWeights} ${pipelineWeightsDir}/"
String smokeXmlReport = 'cypress/reports/smokeXmlReport.html'
String functionalXmlReport = 'cypress/reports/functionalXmlReport.html'
String functionalOutputDir = 'functional-output/prod/cucumber/'
String functionalReportFile = 'functional-report.html'
String functionalReportName = 'Cucumber Functional Test Report'
String smokeOutputDir = 'smoke-output/prod/cucumber/'
String smokeReportFile = 'smoke-report.html'
String smokeReportName = 'Cucumber Smoke Test Report'
String accountArtifactPath = 'functional-output/account_evidence/created-accounts.json'

// Vault secrets injected into the pipeline
Map<String, Object> secrets = [
  (secretKey): [
    secret('OpalTestUserEmail', 'OPAL_TEST_USER_EMAIL'),
    secret('OpalTestUserPassword', 'OPAL_TEST_USER_PASSWORD')
  ],
]

// Build an Azure KeyVault secret entry
static Map<String, Object> secret(String secretName, String envVar) {
    return [$class     : 'AzureKeyVaultSecret',
    secretType : 'Secret',
    name       : secretName,
    version    : '',
    envVariable: envVar
  ]
}

// Yarn helper for build/test commands
uk.gov.hmcts.contino.YarnBuilder yarnBuilder = new uk.gov.hmcts.contino.YarnBuilder(this)

void archiveArtifact(String path) {
    archiveArtifacts artifacts: path, allowEmptyArchive: true
}

// Publish an HTML report directory with Jenkins HTML Publisher
void publishHtmlReport(String dir, String files, String name) {
    publishHTML target: [
    allowMissing         : true,
    alwaysLinkToLastBuild: true,
    keepAll              : true,
    reportDir            : dir,
    reportFiles          : files,
    reportName           : name
  ]
}

// Resolve project/job name (PR vs master)
String getProjectName() {
    String projectPrefix = 'HMCTS/opal-frontend/'
    GithubAPI githubApi = new GithubAPI(this)
    echo "Branch name: ${env.BRANCH_NAME}"
    echo "Labels: ${githubApi.getLabels(env.BRANCH_NAME)}"
    for (label in githubApi.getLabelsbyPattern(env.BRANCH_NAME, 'opal-frontend-pr-')) {
        String prNumber = label.substring(21, label.length())
        return projectPrefix + 'PR-' + prNumber
    }
    return projectPrefix + 'master'
}
// Collect test/skip labels for routing
List<String> getProjectLabels() {
    GithubAPI githubApi = new GithubAPI(this)
    List<String> testLabels = []
    for (String label in githubApi.getLabelsbyPattern(env.BRANCH_NAME, 'test_')) {
        testLabels.add(label)
    }
    for (String label in githubApi.getLabelsbyPattern(env.BRANCH_NAME, 'skip_')) {
        testLabels.add(label)
    }
    return testLabels
}
// Restore weight files from last successful build
void performArtifactOperations() {
    sh 'mkdir -p cypress/parallel/weights/pipeline'

    sh '''
    echo "Listing all artifacts before copy artifacts:"
    ls -l1a cypress/parallel/weights/
    ls -l1a cypress/parallel/weights/pipeline/
    '''

    script {
        String projectNameValue = projectName
        try {
            copyArtifacts(
                projectName: projectNameValue,
                selector: lastSuccessful(),
                filter: '**/cypress/parallel/weights/pipeline/*'
      )
        } catch (hudson.AbortException e) {
            echo "Error copying artifacts: ${e}"
        }

        sh '''
        echo "Listing all artifacts after copy artifacts:"
        ls -l1a cypress/parallel/weights/
        ls -l1a cypress/parallel/weights/pipeline/
        '''
    }

    try {
        sh """
        if [ -f ${pipelineWeightsDir}/${smokeWeights} ]; then
            mv ${pipelineWeightsDir}/${smokeWeights} ${weightsRoot}/${smokeWeights}
            echo "Moved smoke-parallel-weights.json"
        else
            echo "smoke-parallel-weights.json not found, skipping move"
        fi
        if [ -f ${pipelineWeightsDir}/${functionalWeights} ]; then
            mv ${pipelineWeightsDir}/${functionalWeights} ${weightsRoot}/${functionalWeights}
            echo "Moved functional-parallel-weights.json"
        else
            echo "functional-parallel-weights.json not found, skipping move"
        fi
        if [ -f ${pipelineWeightsDir}/${componentWeights} ]; then
            mv ${pipelineWeightsDir}/${componentWeights} ${weightsRoot}/${componentWeights}
            echo "Moved component-parallel-weights.json"
        else
            echo "component-parallel-weights.json not found, skipping move"
        fi
        """
    } catch (hudson.AbortException e) {
        echo "Artifacts not found or copy failed: ${e}"
    }

    sh '''
    echo "Listing all copied artifacts:"
    ls -l1a cypress/parallel/weights/
    ls -l1a cypress/parallel/weights/pipeline/
    '''
}

// Set TEST_SPECS based on labels or default to all
void setupTestSpecifications() {
    script {
        String projectNameValue = projectName
        List<String> labels = projectLabels
        sh "echo 'Test Labels: ${labels}'"

        List<String> directories = []

        // Add additional labels as needed
        if (labels.contains('test_authorisation')) {
      directories.add('authorisation')
        }
        if (labels.contains('test_enq')) {
            directories.add('accountEnquiry')
        }
        if (labels.contains('test_remo')) {
            directories.add('reciprocalMaintenance')
        }
        if (labels.contains('test_mac')) {
            directories.add('manualAccountCreation')
        }
        sh "echo 'Directories: ${directories}'"

        if (directories.empty || projectNameValue == 'HMCTS/opal-frontend/master') {
            // No specific test labels, include all directories
            env.TEST_SPECS = 'cypress/e2e/functional/opal/**/*.feature'
        } else {
            // Build the glob pattern using curly braces
            String dirList = directories.join(',')
            env.TEST_SPECS = "cypress/e2e/functional/opal/{required,${dirList}}/**/*.feature"
        }
        sh "echo 'Test Specs: ${env.TEST_SPECS}'"
    }
}

// Configure PR env deployment for dev fines service
void determineDevEnvironmentDeployment() {
    env.DEV_ENABLE_OPAL_FINES_SERVICE = true // Default to true for development environment as FE wont work without it
    env.DEV_OPAL_FINES_SERVICE_URL = "https://opal-frontend-pr-${env.CHANGE_ID}-fines-service.dev.platform.hmcts.net"
    env.DEV_OPAL_FINES_SERVICE_IMAGE_SUFFIX = 'latest'

    GithubAPI githubApi = new GithubAPI(this)
    if (githubApi.checkForLabel(env.BRANCH_NAME, 'enable_keep_helm')) {
        for (label in githubApi.getLabelsbyPattern(env.BRANCH_NAME, 'enable_opal_')) {
            //Fines service
            if (label ==~ /enable_opal_fines_service.*/) {
                env.DEV_ENABLE_OPAL_FINES_SERVICE = true
                env.DEV_OPAL_FINES_SERVICE_URL =
          "https://opal-frontend-pr-${env.CHANGE_ID}-fines-service.dev.platform.hmcts.net"
                if (label ==~ /enable_opal_fines_service:pr-.*/) {
                    env.DEV_OPAL_FINES_SERVICE_IMAGE_SUFFIX = label.replace('enable_opal_fines_service:', '')
                }
                echo "Deploying Opal fines service ${env.DEV_OPAL_FINES_SERVICE_URL}"
            }
        }
    }
}

// Fail the build if .only or @only are present
void checkFocusedTests() {
    sh '''
    echo "=== Focused test checks (component + feature) ==="
    set +e
    COMPONENT_ONLY_FILES=$(grep -R -l --include='*.cy.ts' '\\.only' cypress/component 2>/dev/null)
    FEATURE_ONLY_FILES=$(grep -R -l --include='*.feature' '@only' cypress/e2e/functional/opal/features 2>/dev/null)
    set -e

    HAS_FAILURE=0

    if [ -n "$COMPONENT_ONLY_FILES" ]; then
      echo ""
      echo "Found focused component specs (.only):"
      echo "$COMPONENT_ONLY_FILES" | sed 's/^/ - /'
      HAS_FAILURE=1
    else
      echo "No focused component specs found."
    fi

    if [ -n "$FEATURE_ONLY_FILES" ]; then
      echo ""
      echo "Found @only tags in feature files:"
      echo "$FEATURE_ONLY_FILES" | sed 's/^/ - /'
      HAS_FAILURE=1
    else
      echo "No @only tags found in feature files."
    fi

    if [ "$HAS_FAILURE" -eq 1 ]; then
      echo ""
      echo "FAIL: Remove the focused tests above before running component tests."
      exit 1
    fi
    echo "Focused test checks passed."
  '''
}

properties([
  // Permit dependent jobs to copy artifacts from this build
  copyArtifactPermission('*')
])

// --- Dev legacy toggle (PR label driven) ---
def githubApiForMode = new GithubAPI(this)
def legacyEnabled = githubApiForMode.checkForLabel(env.BRANCH_NAME, 'enable_legacy_mode')
def isPR = env.CHANGE_ID?.trim()

// Safe defaults (current behaviour)
env.DEV_DEFAULT_APP_MODE = 'opal'
env.DEV_OPAL_LEGACY_GATEWAY_URL = 'https://opal-legacy-db-stub.staging.platform.hmcts.net/opal'

// Opt-in: Dev â†’ JCDE (PR builds only)
if (legacyEnabled && isPR) {
  env.DEV_DEFAULT_APP_MODE = 'legacy'
  env.DEV_OPAL_LEGACY_GATEWAY_URL = 'https://opal.clouddev.online/opal'
} else if (legacyEnabled && !isPR) {
  echo "Legacy mode label detected but this is not a PR build; ignoring."
}

echo "DEV_DEFAULT_APP_MODE=${env.DEV_DEFAULT_APP_MODE}"
echo "DEV_OPAL_LEGACY_GATEWAY_URL=${env.DEV_OPAL_LEGACY_GATEWAY_URL}"

def githubApi = new GithubAPI(this)
def allLabels = githubApi.getLabels(env.BRANCH_NAME)

// Find the first label like: run_tag:<expression>
def tagLabel = allLabels.find { it.startsWith('run_tag:') }

if (tagLabel) {
  env.TAGS = tagLabel.substring('run_tag:'.length()).trim()
  echo "Running only scenarios matching TAGS=${env.TAGS}"
} else {
  echo "Running all scenarios (no run_tag label found)"
}

// Primary pipeline definition and lifecycle hooks
withPipeline(type, product, component) {
    // Inject KeyVault secrets required for login/setup
    loadVaultSecrets(secrets)

    // Configure PR-only deployment knobs before helm installs run
    before('akschartsinstall') {
        onPR {
            determineDevEnvironmentDeployment()
        }
    }

    // Build frontend bundle after checkout when previous steps succeed
    afterSuccess(stageBuild) {
        yarnBuilder.yarn('rebuild puppeteer')
        yarnBuilder.yarn(stageBuild)
    }

    // Restore previous parallelization weights and set test spec globs
    afterSuccess('checkout') {
        performArtifactOperations()
        setupTestSpecifications()
        script {
            List<String> labels = projectLabels
            if (labels.contains(skipLabelComponent)) {
                echo "Skipping focused test checks due to label: ${skipLabelComponent}"
            } else {
                echo 'Running focused test checks (no skip label present)'
                checkFocusedTests()
            }
        }
    }

    // Persist updated component weights after component test stage
    afterSuccess(stageTest) {
        script {
            String sourceJobName = env.JOB_NAME
            sh "${mkdirPipelineCmd}"
            sh '''
          if [ -f cypress/parallel/weights/component-parallel-weights.json ]; then
            cp -r cypress/parallel/weights/component-parallel-weights.json cypress/parallel/weights/pipeline/
          else
            echo "component-parallel-weights.json not found, skipping copy"
          fi
          '''
            sh"echo 'Archiving weight files in ${sourceJobName}'"
            archiveArtifacts(
          artifacts: "${pipelineWeightsDir}/${componentWeights}",
          allowEmptyArchive: true
        )
        }
    }

    // Always run component suite unless explicitly skipped; publish artifacts
    afterAlways(stageTest) {
        script {
            List<String> labels = projectLabels
            if (labels.contains(skipLabelComponent)) {
                echo "Skipping opal component tests due to label: ${skipLabelComponent}"
      } else {
                echo 'Running opal component tests (no skip label present)'
                try {
                    yarnBuilder.yarn('test:opalComponent')
        } catch (hudson.AbortException e) {
                    echo "Opal component tests failed: ${e}"
                    currentBuild.result = 'FAILURE'
        } finally {
                    archiveArtifact('functional-output/**')
                    publishHtmlReport('functional-output/component-report/', 'index.html', 'Component Test Report')
                }
            }
        }
    }

    // Archive smoke/functional weights and reports after dev functional run
    afterSuccess(stageFunctionalDev) {
        script {
            String sourceJobName = env.JOB_NAME
            sh "${mkdirPipelineCmd}"
            sh "${copySmokeToPipelineCmd}"
            sh "${copyFunctionalToPipelineCmd}"

            sh"echo 'Archiving weight files in ${sourceJobName}'"
            archiveArtifact("${pipelineWeightsDir}/${smokeWeights}")
            archiveArtifact("${pipelineWeightsDir}/${functionalWeights}")
            archiveArtifact(smokeXmlReport)
            archiveArtifact(functionalXmlReport)
        }
    }

    // Archive smoke/functional weights and reports after staging functional run
    afterSuccess(stageFunctionalStg) {
        script {
            String sourceJobName = env.JOB_NAME
            sh "${mkdirPipelineCmd}"
            sh "${copySmokeToPipelineCmd}"
            sh "${copyFunctionalToPipelineCmd}"

            sh"echo 'Archiving weight files in ${sourceJobName}'"
            archiveArtifact("${pipelineWeightsDir}/${smokeWeights}")
            archiveArtifact("${pipelineWeightsDir}/${functionalWeights}")
            archiveArtifact(smokeXmlReport)
            archiveArtifact(functionalXmlReport)
        }
    }

    // Publish HTML and JSON artifacts for staging functional runs
    afterAlways(stageFunctionalStg) {
        publishHtmlReport(
        functionalOutputDir,
        functionalReportFile,
        functionalReportName
      )
        archiveArtifact(accountArtifactPath)
        publishHtmlReport(
        smokeOutputDir,
        smokeReportFile,
        smokeReportName
      )
    }
    // Publish HTML and JSON artifacts for dev functional runs
    afterAlways(stageFunctionalDev) {
        publishHtmlReport(
        functionalOutputDir,
        functionalReportFile,
        functionalReportName
      )
        archiveArtifact(accountArtifactPath)

        publishHtmlReport(
        smokeOutputDir,
        smokeReportFile,
        smokeReportName
      )
    }
}
